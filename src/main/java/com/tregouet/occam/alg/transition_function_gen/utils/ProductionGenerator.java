package com.tregouet.occam.alg.transition_function_gen.utils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.tregouet.occam.data.concepts.IDenotation;
import com.tregouet.occam.data.languages.ISymbol;
import com.tregouet.occam.data.languages.generic.AVariable;
import com.tregouet.occam.data.languages.generic.IConstruct;
import com.tregouet.occam.data.languages.generic.impl.Construct;
import com.tregouet.occam.data.languages.generic.impl.Terminal;
import com.tregouet.occam.data.languages.specific.IBasicProduction;
import com.tregouet.occam.data.languages.specific.impl.BasicProduction;
import com.tregouet.occam.data.languages.specific.impl.BasicProductionAsEdge;
import com.tregouet.occam.data.languages.specific.impl.EpsilonAsEdge;

public class ProductionGenerator {

	private List<IBasicProduction> productions = null;
	
	/**
	 * Meaningless if Concepts.isA(operatorInput.cat, operatorOutput.cat) == false
	 * @param operatorInput
	 * @param operatorOutput
	 */
	public ProductionGenerator(IDenotation operatorInput, IDenotation operatorOutput) {
		if (operatorInput.getListOfSymbols().equals(operatorOutput.getListOfSymbols()))
			productions = new ArrayList<>(
					Arrays.asList(new IBasicProduction[] {new EpsilonAsEdge(operatorInput, operatorOutput)}));
		else if (operatorInput.getListOfTerminals().containsAll(operatorOutput.getListOfTerminals())) {
			//then input is an instance of output
			List<ISymbol> source = operatorInput.getListOfSymbols();
			List<ISymbol> target = operatorOutput.getListOfSymbols();
			Map<AVariable, List<ISymbol>> varToValue = mapVariablesToValues(source, target);
			if (varToValue != null) {
				productions = new ArrayList<>();
				for (AVariable variable : varToValue.keySet()) {
					IConstruct value;
					List<ISymbol> listOfSymbols = varToValue.get(variable);
					if (listOfSymbols.isEmpty()) {
						List<ISymbol> emptyString = 
								new ArrayList<>(Arrays.asList(new ISymbol[] {new Terminal(IConstruct.EMPTY_CONSTRUCT_SYMBOL)}));
						value = new Construct(emptyString);
					}
					else value = new Construct(listOfSymbols);
					IBasicProduction basicProd = new BasicProduction(variable, value);
					productions.add(new BasicProductionAsEdge(operatorInput, operatorOutput, basicProd));
				}
			}
		}
	}
	
	/**
	 * Public for test use
	 * @param source
	 * @param target
	 * @return
	 */
	public static Map<AVariable, List<ISymbol>> mapVariablesToValues(List<ISymbol> source, List<ISymbol> target) {
		return continueMapping(source, target, new HashMap<AVariable, List<ISymbol>>(), 0, 0);
	}
	
	private static Map<AVariable, List<ISymbol>> continueMapping(List<ISymbol> source, List<ISymbol> target, 
			Map<AVariable, List<ISymbol>> varToValue, int srcIdx, int targetIdx) {
		if (srcIdx == source.size() && targetIdx == target.size())
			return varToValue;
		if (srcIdx == source.size() || targetIdx == target.size())
			return null;		
		if (target.get(targetIdx) instanceof AVariable) {
			AVariable variable = (AVariable) target.get(targetIdx);
			int varSpan = 0;
			Map<AVariable, List<ISymbol>> nextMap = null;
			while (nextMap == null && (srcIdx + varSpan <= source.size())) {
				nextMap = deepCopy(varToValue);
				nextMap.put(variable, new ArrayList<ISymbol>());
				int srcAdvance = 0;
				while (srcAdvance < varSpan) {
					nextMap.get(variable).add(source.get(srcIdx + srcAdvance));
					srcAdvance++;
				}					
				nextMap = continueMapping(source, target, nextMap, srcIdx + srcAdvance, targetIdx + 1);
				varSpan++;
			}
			return nextMap;
		}
		else {
			if (source.get(srcIdx).equals(target.get(targetIdx))) {
				return continueMapping(source, target, varToValue, srcIdx + 1, targetIdx + 1);
			}
			return null;
		}
	}
	
	private static Map<AVariable, List<ISymbol>> deepCopy(Map<AVariable, List<ISymbol>> map){
		Map<AVariable, List<ISymbol>> mapDeepCopy = new HashMap<>();
		for (AVariable key : map.keySet()) {
			mapDeepCopy.put(key, new ArrayList<ISymbol>(map.get(key)));
		}
		return mapDeepCopy;
	}
	
	/**
	 * 
	 * @return null if constr param1 can't be generated by constr param2, a list only containing a BlankProduction if 
	 * they have the same list of symbols, a list of Productions otherwise
	 */
	public List<IBasicProduction> getProduction() {
		return productions;
	}

}
